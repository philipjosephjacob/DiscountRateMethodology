using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Text;
using System.Text.Json.Serialization;

namespace KrollDiscounting.Entities
{
    /// <summary>
    /// Base class for bonds. 
    /// </summary>
    [Table("Bonds")]
    public abstract class Bond : IEquatable<Bond>
    {

        /// <summary>
        /// Using GUID as primary key for uniqueness across distributed systems.
        /// This Id is generated by the database upon insertion.
        /// Performance will be poorer than using consecutive integers.
        /// </summary>
        [Key,JsonIgnore]
        public Guid Id { get; set; }


        /// <summary>
        /// Gets or sets the International Securities Identification Number (ISIN) associated with the financial
        /// instrument. Added as example for illustration purposes. More likely production implementation with base clas
        /// for identifiers and derived classes for ISIN, CUSIP, SEDOL, etc.
        /// </summary>
        /// <remarks>The ISIN is a unique 12-character alphanumeric code used to identify securities
        /// internationally. The value must not exceed 12 characters in length.</remarks>
        [MaxLength(12)]
        public string? ISIN { get; set; }

        /// <summary>
        /// Gets or sets the CUSIP identifier associated with the financial instrument.
        /// </summary>
        /// <remarks>The CUSIP is a unique 9-character alphanumeric code used to identify securities in
        /// the United States and Canada. The value should be a valid CUSIP; otherwise, downstream systems may reject or
        /// misinterpret the instrument.</remarks>
        [MaxLength(9)]
        public string? CUSIP { get; set; }

        [Required]
        [MaxLength(200)]
        public string Name { get; set; } = string.Empty;

        // Use DateOnly for date-only semantics (.NET 6+). 
        public DateOnly IssueDate { get; set; }
        public DateOnly MaturityDate { get; set; }

        /// <summary>
        /// Gets or sets the face value of the item, expressed as a monetary amount.
        /// Use of decimal type for precision matching real-world precision of quotes.
        /// Internal calculations may convert to double.
        /// </summary>
        [Column(TypeName = "decimal(18,2)")]
        public decimal FaceValue { get; set; }

        [MaxLength(3)]
        public string? Currency { get; set; }



        public DateTimeOffset CreatedAt { get; set; }
        public DateTimeOffset? UpdatedAt { get; set; }

        // Concurrency token for EF
        [Timestamp]
        public byte[]? RowVersion { get; set; }

        /// <summary>
        /// Base method to calculate Yield to Maturity (YTM) from the given price and market date.
        /// </summary>
        /// <param name="price"></param>
        /// <param name="marketDate"></param>
        /// <returns>YTM calculated from price using optimisation or closed-form depending on type of bond.</returns>
        public abstract double GetYTMFromPrice(double price, DateOnly marketDate);

        /// <summary>
        /// Utility to convert dates into fraction of year.
        /// Implements Actual/Actual day count convention, but real implementation would take day count convention as parameter.
        /// </summary>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <returns>Fraction of year oas floating point number</returns>
        protected static double GetYearFraction(DateOnly startDate, DateOnly endDate)
        {
            // Calculate the difference in days
            int totalDays = (endDate.ToDateTime(TimeOnly.MinValue) - startDate.ToDateTime(TimeOnly.MinValue)).Days;

            // Determine the number of days in the year of the start date
            // This approach considers the year of the start date for the year length
            int daysInYear = DateTime.IsLeapYear(startDate.Year) ? 366 : 365;

            // Calculate the fraction of the year
            return (double)totalDays / daysInYear;
        }

        /// <summary>
        /// Abstract method to get the coupon rate as a decimal (e.g., 0.05 for 5%).
        /// </summary>
        /// <returns></returns>
        protected abstract double GetCouponRate();

        /// <summary>
        /// Returns the number of payment periods per year for the current payment schedule.
        /// </summary>
        /// <returns>An integer representing the frequency of payments per year. For example, 1 for annual payments, 12 for
        /// monthly payments.</returns>
        protected virtual int GetPaymentFrequency()
        {
            return 1;
        }

        /// <summary>
        /// Calculates the price of the bond based on the specified yield to maturity (YTM) and market date.
        /// </summary>
        /// <remarks>The calculation assumes fixed coupon payments and payment frequency as defined by the
        /// bond. The method discounts all future cash flows using the provided YTM and payment frequency.  Actual impkemnentation sould use 
        /// a daycount convention.</remarks>
        /// <param name="ytm">The annual yield to maturity, expressed as a decimal (for example, 0.05 for 5%). Must be non-negative.</param>
        /// <param name="marketDate">The market date used to determine the time to maturity for pricing the bond.</param>
        /// <returns>The present value of the bond, calculated as the sum of discounted future coupon payments and face value as
        /// of the specified market date.</returns>
        public double PriceBondFromYTM(double ytm,DateOnly marketDate)
        {
            var couponRate = GetCouponRate();
            var frequency = GetPaymentFrequency();
            var faceValue = (double)FaceValue;
            int yearsToMaturity = (int)Math.Floor(GetYearFraction(marketDate, MaturityDate));

            double couponPayment = (faceValue * couponRate) / frequency;
            int totalPeriods = yearsToMaturity * frequency;
            double pvCoupons = 0;
            for (int t = 1; t <= totalPeriods; t++)
            {
                pvCoupons += couponPayment / Math.Pow(1 + ytm / frequency, t);
            }
            double pvFaceValue = faceValue / Math.Pow(1 + ytm / frequency, totalPeriods);

            double price = pvCoupons + pvFaceValue;
            return price;
        }

        public virtual bool Equals(Bond other)
        {
            if (other is null)
                return false;
            if (ReferenceEquals(this, other))
                return true;
            if (this.GetType() != other.GetType())
            {
                return false;
            }

            // don't check ID
            return Name == other.Name &&
                Name == other.Name && 
                CUSIP == other.CUSIP &&
                ISIN == other.ISIN &&
                IssueDate == other.IssueDate &&
                MaturityDate == other.MaturityDate &&
                FaceValue == other.FaceValue &&
                Currency == other.Currency;
        }

        public override bool Equals(object obj)
        {

            return Equals(obj as Bond);
        }

        public override int GetHashCode()
        {

            return HashCode.Combine( Name, CUSIP, ISIN, IssueDate, MaturityDate, FaceValue, Currency);
        }
    }

    /// <summary>
    /// Properties shown are examples specific to corporate bonds. 
    /// In real-life would likely have abstract class representing attributes and concretes for ratings,
    /// industries, geographies etc so behavior can be bound to the data in type-safe form.
    /// </summary>
    public abstract class CorporateBond : Bond
    {
        [MaxLength(100)]
        public string? Industry { get; set; }

        public bool Equals(CorporateBond other)
        {
            if (other is null) return false;

            if (!base.Equals(other))
            {
                return false;
            }


            return Industry == other.Industry;
        }

  
        public override bool Equals(object obj)
        {

            return Equals(obj as CorporateBond);
        }


        public override int GetHashCode()
        {

            return HashCode.Combine(base.GetHashCode(), Industry==null? String.Empty: Industry);
        }
    }

    /// <summary>
    /// Represents a zero-coupon corporate bond, which pays no periodic interest and is redeemed at face value upon
    /// maturity.
    /// </summary>
    public class ZeroCouponCorporateBond : CorporateBond
    {
        /// <summary>
        /// Calculates the yield to maturity (YTM) of the bond based on the specified market price and market date.
        /// In real life, should take day count convention as parameter.
        /// </summary>
        /// <param name="price">The current market price of the bond. Must be greater than zero.</param>
        /// <param name="marketDate">The date on which the bond price is observed. Used to determine the time to maturity.</param>
        /// <returns>The yield to maturity as a double-precision floating-point value.</returns>
        /// <exception cref="ArgumentException">Thrown when <paramref name="price"/> is less than or equal to zero.</exception>

        public override double GetYTMFromPrice(double price, DateOnly marketDate)
        {
            {

                if (price <= 0) throw new ArgumentException("Price must be greater than zero.", nameof(price));

                double yearsToMat= GetYearFraction(marketDate, MaturityDate );
       
                return Math.Pow((double)FaceValue / (double) price, (1.0/yearsToMat)); 
            }
        }

        /// <summary>
        /// Returns the coupon rate for the financial instrument.
        /// </summary>
        /// <remarks>Override this method in a derived class to provide the actual coupon rate for
        /// instruments that pay interest.</remarks>
        /// <returns>A double value representing the coupon rate. The value is 0.0 if the instrument does not pay interest.</returns>
        protected override double GetCouponRate()
        {
            return 0.0;
        }


    }
    /// <summary>
    /// Simple representation of a coupon-paying corporate bond.
    /// </summary>

    public class CouponCorporateBond : CorporateBond
    {
        /// <summary>
        /// Gets or sets the coupon rate as a percentage for the financial instrument.
        /// Internally converted to float for calculations.
        /// </summary>
        [Column(TypeName = "decimal(5,2)")]
        public decimal CouponRatePct { get; set; }

        /// <summary>
        /// Coupon payment frequency per year (e.g., 1 for annual, 2 for semi-annual, 4 for quarterly).
        /// </summary>
        public int CouponFrequencyPerYear { get; set; }

        protected override int GetPaymentFrequency()
        {
            return CouponFrequencyPerYear;
        }

        /// <summary>
        /// Override base class
        /// </summary>
        /// <returns>As base class</returns>
        protected override double GetCouponRate()
        {
            return (double)CouponRatePct;
        }

        /// <summary>
        /// Calculates the yield to maturity (YTM) of the bond based on the specified market price and years to maturity.
        /// </summary>
        /// <param name="price"></param>
        /// <param name="yearsToMaturity"></param>
        /// <param name="initialGuess"></param>
        /// <param name="tolerance"></param>
        /// <param name="maxIterations"></param>
        /// <returns></returns>
        /// <exception cref="InvalidOperationException"></exception>
        public double CalculateYieldToMaturity(double price, 
                                                int yearsToMaturity, 
                                                double initialGuess = 0.05, 
                                                double tolerance = 1e-7, 
                                                int maxIterations = 100)
        {
            double faceValue = (double)FaceValue;
            double couponRate = ((double)this.CouponRatePct) / 100.0;

            double couponPayment = (faceValue * couponRate) / CouponFrequencyPerYear;
            int couponPeriods = yearsToMaturity * CouponFrequencyPerYear;

            double ytm = initialGuess; // Initial guess for YTM

            for (int i = 0; i < maxIterations; i++)
            {


                double pvCoupons = 0;
                for (int t = 1; t <= couponPeriods; t++)
                {
                    pvCoupons += couponPayment / Math.Pow(1 + ytm / CouponFrequencyPerYear, t);
                }
                double pvFaceValue = faceValue / Math.Pow(1 + ytm / CouponFrequencyPerYear, couponPeriods);

                double currentPriceEstimate = pvCoupons + pvFaceValue;
                double functionValue = currentPriceEstimate - (price* faceValue);

                // Gradient calculation
                double derivative = 0;
                for (int t = 1; t <= couponPeriods; t++)
                {
                    derivative -= (t * couponPayment) / (CouponFrequencyPerYear * Math.Pow(1 + ytm / CouponFrequencyPerYear, t + 1));
                }
                derivative -= (couponPeriods * faceValue) / (CouponFrequencyPerYear * Math.Pow(1 + ytm / CouponFrequencyPerYear, couponPeriods + 1));

                double nextYtm = ytm - (functionValue / derivative);

                if (Math.Abs(nextYtm - ytm) < tolerance)
                {
                    return nextYtm; // YTM found within tolerance
                }

                ytm = nextYtm;
            }

            throw new InvalidOperationException("YTM calculation did not converge within the maximum number of iterations.");
        }
        public override double GetYTMFromPrice(double price, DateOnly marketDate)
        {
            return CalculateYieldToMaturity(price, (int)GetYearFraction(marketDate, MaturityDate));

        }

        public bool Equals(CouponCorporateBond other)
        {
            if (other is null) return false;

            if (!base.Equals(other))
            {
                return false;
            }


            return CouponRatePct == other.CouponRatePct &&
                   CouponFrequencyPerYear == other.CouponFrequencyPerYear;
            
        }


        public override bool Equals(object obj)
        {

            return Equals(obj as CouponCorporateBond);
        }


        public override int GetHashCode()
        {

            return HashCode.Combine(base.GetHashCode(), CouponFrequencyPerYear);
        }
    }
}
